# 审批系统 - 文件存储实施文档

## 1. 存储方案概述

本系统采用**本地磁盘存储**方案，文件直接存入服务器指定文件夹，通过静态资源映射提供访问。

| 项目 | 说明 |
|------|------|
| 存储方式 | 本地磁盘 |
| 存储路径 | D:/uploads/approval-system |
| 访问方式 | 静态资源映射 |
| 访问路径 | /files/** |

## 2. 目录结构

```
D:/uploads/approval-system/
├── 2026/                      # 按年份分目录
│   ├── 01/                    # 按月份分目录
│   │   ├── 13/                # 按日期分目录
│   │   │   ├── uuid-1.docx
│   │   │   ├── uuid-2.pdf
│   │   │   └── uuid-3.xlsx
│   │   └── 14/
│   └── 02/
└── avatar/                    # 用户头像
    ├── 1.jpg
    └── 2.jpg
```

## 3. 后端配置

### 3.1 应用配置 (application.yml)

```yaml
# 文件上传配置
file:
  # 上传文件存储目录
  upload-dir: D:/uploads/approval-system
  # 访问路径前缀
  access-path: /files
  # 允许的文件类型
  allowed-types: doc,docx,xls,xlsx,ppt,pptx,pdf,txt,jpg,jpeg,png,gif,zip,rar
  # 单文件最大大小 (50MB)
  max-size: 52428800

spring:
  servlet:
    multipart:
      max-file-size: 50MB
      max-request-size: 50MB
```

### 3.2 静态资源映射 (WebMvcConfig.java)

```java
/**
 * WebMvc 配置类
 * 配置静态资源映射
 */
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Value("${file.upload-dir}")
    private String uploadDir;

    @Value("${file.access-path}")
    private String accessPath;

    /**
     * 配置静态资源映射
     * 将 /files/** 映射到本地磁盘目录
     */
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(accessPath + "/**")
                .addResourceLocations("file:" + uploadDir + "/");
    }
}
```

### 3.3 文件工具类 (FileUtil.java)

```java
/**
 * 文件操作工具类
 */
@Component
@Slf4j
public class FileUtil {

    @Value("${file.upload-dir}")
    private String uploadDir;

    @Value("${file.allowed-types}")
    private String allowedTypes;

    @Value("${file.max-size}")
    private long maxSize;

    /**
     * 上传文件
     * @param file 上传的文件
     * @return 文件存储信息
     */
    public FileInfo uploadFile(MultipartFile file) {
        // 验证文件
        validateFile(file);

        // 生成存储路径
        String datePath = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));
        String storedName = UUID.randomUUID().toString() + getExtension(file.getOriginalFilename());
        String relativePath = datePath + "/" + storedName;
        String fullPath = uploadDir + "/" + relativePath;

        // 创建目录
        File dir = new File(uploadDir + "/" + datePath);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        // 保存文件
        try {
            file.transferTo(new File(fullPath));
        } catch (IOException e) {
            log.error("文件上传失败", e);
            throw new BusinessException("文件上传失败");
        }

        return FileInfo.builder()
                .originalName(file.getOriginalFilename())
                .storedName(storedName)
                .filePath("/files/" + relativePath)
                .fileSize(file.getSize())
                .fileType(getExtension(file.getOriginalFilename()).replace(".", ""))
                .mimeType(file.getContentType())
                .build();
    }

    /**
     * 删除文件
     */
    public boolean deleteFile(String filePath) {
        String fullPath = uploadDir + filePath.replace("/files", "");
        File file = new File(fullPath);
        if (file.exists()) {
            return file.delete();
        }
        return false;
    }

    /**
     * 验证文件
     */
    private void validateFile(MultipartFile file) {
        if (file.isEmpty()) {
            throw new BusinessException("文件不能为空");
        }

        if (file.getSize() > maxSize) {
            throw new BusinessException("文件大小超出限制（最大50MB）");
        }

        String ext = getExtension(file.getOriginalFilename()).replace(".", "").toLowerCase();
        List<String> allowed = Arrays.asList(allowedTypes.split(","));
        if (!allowed.contains(ext)) {
            throw new BusinessException("不支持的文件类型");
        }
    }

    /**
     * 获取文件扩展名
     */
    private String getExtension(String filename) {
        if (filename == null) return "";
        int dotIndex = filename.lastIndexOf(".");
        return dotIndex > 0 ? filename.substring(dotIndex) : "";
    }
}
```

### 3.4 文件控制器 (FileController.java)

```java
/**
 * 文件上传控制器
 */
@RestController
@RequestMapping("/api/v1/files")
@RequiredArgsConstructor
public class FileController {

    private final FileUtil fileUtil;
    private final AttachmentService attachmentService;

    /**
     * 上传文件
     */
    @PostMapping("/upload")
    public Result<AttachmentVO> upload(@RequestParam("file") MultipartFile file) {
        // 上传文件到磁盘
        FileInfo fileInfo = fileUtil.uploadFile(file);
        
        // 保存附件记录到数据库
        Attachment attachment = attachmentService.save(fileInfo);
        
        return Result.success(AttachmentVO.from(attachment));
    }

    /**
     * 下载文件
     */
    @GetMapping("/download/{id}")
    public ResponseEntity<Resource> download(@PathVariable String id) {
        Attachment attachment = attachmentService.getById(id);
        if (attachment == null) {
            throw new BusinessException(404, "文件不存在");
        }

        Path path = Paths.get(attachment.getFilePath());
        Resource resource = new UrlResource(path.toUri());

        return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .header(HttpHeaders.CONTENT_DISPOSITION, 
                        "attachment; filename=\"" + attachment.getOriginalName() + "\"")
                .body(resource);
    }
}
```

## 4. 前端文件上传

### 4.1 文件上传组件

```tsx
import { useState, useCallback } from 'react'
import { Button } from '@/components/ui/button'
import { Progress } from '@/components/ui/progress'
import { upload } from '@/services/api'
import { Upload, X, File } from 'lucide-react'

interface FileUploaderProps {
  onChange?: (files: UploadedFile[]) => void
  maxCount?: number
  accept?: string
}

export function FileUploader({ onChange, maxCount = 5, accept }: FileUploaderProps) {
  const [files, setFiles] = useState<UploadedFile[]>([])
  const [uploading, setUploading] = useState(false)
  const [progress, setProgress] = useState(0)

  const handleUpload = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    setUploading(true)
    try {
      const result = await upload('/api/v1/files/upload', file, setProgress)
      const newFiles = [...files, result]
      setFiles(newFiles)
      onChange?.(newFiles)
    } catch (error) {
      console.error('上传失败', error)
    } finally {
      setUploading(false)
      setProgress(0)
    }
  }, [files, onChange])

  const handleRemove = useCallback((id: string) => {
    const newFiles = files.filter(f => f.id !== id)
    setFiles(newFiles)
    onChange?.(newFiles)
  }, [files, onChange])

  return (
    <div className="space-y-4">
      {/* 上传按钮 */}
      <label className="flex items-center justify-center w-full h-32 border-2 border-dashed rounded-lg cursor-pointer hover:bg-gray-50">
        <div className="flex flex-col items-center">
          <Upload className="w-8 h-8 text-gray-400" />
          <span className="mt-2 text-sm text-gray-500">点击上传文件</span>
        </div>
        <input
          type="file"
          className="hidden"
          accept={accept}
          onChange={handleUpload}
          disabled={uploading || files.length >= maxCount}
        />
      </label>

      {/* 上传进度 */}
      {uploading && <Progress value={progress} />}

      {/* 文件列表 */}
      <div className="space-y-2">
        {files.map(file => (
          <div key={file.id} className="flex items-center justify-between p-2 bg-gray-50 rounded">
            <div className="flex items-center">
              <File className="w-4 h-4 mr-2" />
              <span className="text-sm">{file.fileName}</span>
            </div>
            <Button variant="ghost" size="sm" onClick={() => handleRemove(file.id)}>
              <X className="w-4 h-4" />
            </Button>
          </div>
        ))}
      </div>
    </div>
  )
}
```

## 5. 安全注意事项

1. **文件类型验证**：后端必须验证文件类型，不能仅依赖前端
2. **文件大小限制**：限制单文件和总请求大小
3. **文件名处理**：使用 UUID 重命名，避免路径遍历攻击
4. **存储路径**：文件存储目录不应在 Web 根目录下
5. **权限控制**：敏感文件需要认证后才能访问

## 6. 扩展建议

如果未来需要扩展，可考虑：

1. **对象存储**：迁移到 MinIO、阿里云 OSS 等
2. **文件预览**：集成 kkFileView 实现在线预览
3. **图片处理**：使用 Thumbnailator 生成缩略图
4. **文件加密**：对敏感文件进行加密存储
